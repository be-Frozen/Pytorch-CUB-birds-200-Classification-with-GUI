# -*- coding: utf-8 -*-
import cv2
import requests
import torch
import torchvision
# Form implementation generated from reading ui file 'CUB-birds-200-classification.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPixmap, QPainter, qRed, qGreen, qBlue, qAlpha, QImage
from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView, QFileDialog, QDialog, QVBoxLayout, QTextEdit
import os
from PyQt5.QtWidgets import QMainWindow, QApplication
from PyQt5.QtCore import Qt
from PyQt5.uic import loadUi
import numpy as np
from skimage.feature import local_binary_pattern, hog
import matplotlib.pyplot as plt
from PIL import Image
from io import BytesIO
from torchvision import datasets, transforms, models
from torch import nn
import time


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1115, 750)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.load_Image = QtWidgets.QPushButton(self.centralwidget)
        self.load_Image.setGeometry(QtCore.QRect(570, 80, 501, 41))
        self.load_Image.setObjectName("load_Image")
        self.Title = QtWidgets.QLabel(self.centralwidget)
        self.Title.setGeometry(QtCore.QRect(360, 20, 411, 51))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(17)
        font.setBold(True)
        font.setItalic(False)
        font.setUnderline(False)
        font.setWeight(75)
        font.setStrikeOut(False)
        font.setKerning(False)
        self.Title.setFont(font)
        self.Title.setObjectName("Title")
        self.showresult = QtWidgets.QGraphicsView(self.centralwidget)
        self.showresult.setGeometry(QtCore.QRect(570, 120, 501, 411))
        self.showresult.setObjectName("showresult")
        self.classification_result = QtWidgets.QLabel(self.centralwidget)
        self.classification_result.setGeometry(QtCore.QRect(630, 610, 500, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(16)
        font.setBold(True)
        font.setWeight(75)
        self.classification_result.setFont(font)
        self.classification_result.setObjectName("classification_result")
        self.Author = QtWidgets.QLabel(self.centralwidget)
        self.Author.setGeometry(QtCore.QRect(900, 30, 151, 21))
        self.Author.setObjectName("Author")
        self.select_class = QtWidgets.QComboBox(self.centralwidget)
        self.select_class.setGeometry(QtCore.QRect(140, 520, 281, 31))
        self.select_class.setObjectName("select_class")
        self.select_item = QtWidgets.QComboBox(self.centralwidget)
        self.select_item.setGeometry(QtCore.QRect(140, 570, 281, 31))
        self.select_item.setObjectName("select_item")
        self.showdataset = QtWidgets.QGraphicsView(self.centralwidget)
        self.showdataset.setGeometry(QtCore.QRect(30, 120, 451, 381))
        self.showdataset.setObjectName("showdataset")
        self.median_filter = QtWidgets.QPushButton(self.centralwidget)
        self.median_filter.setGeometry(QtCore.QRect(570, 530, 201, 31))
        self.median_filter.setObjectName("median_filter")
        self.gaussian_filter = QtWidgets.QPushButton(self.centralwidget)
        self.gaussian_filter.setGeometry(QtCore.QRect(770, 530, 201, 31))
        self.gaussian_filter.setObjectName("gaussian_filter")
        self.LBP = QtWidgets.QPushButton(self.centralwidget)
        self.LBP.setGeometry(QtCore.QRect(570, 560, 101, 31))
        self.LBP.setObjectName("LBP")
        self.HOG = QtWidgets.QPushButton(self.centralwidget)
        self.HOG.setGeometry(QtCore.QRect(970, 530, 101, 31))
        self.HOG.setObjectName("HOG")
        self.birds_classification = QtWidgets.QPushButton(self.centralwidget)
        self.birds_classification.setGeometry(QtCore.QRect(870, 560, 201, 31))
        self.birds_classification.setObjectName("birds_classification")
        self.show_eval = QtWidgets.QPushButton(self.centralwidget)
        self.show_eval.setGeometry(QtCore.QRect(670, 560, 201, 31))
        self.show_eval.setObjectName("show_eval")
        self.show_dataset_title = QtWidgets.QLabel(self.centralwidget)
        self.show_dataset_title.setGeometry(QtCore.QRect(90, 70, 381, 41))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(11)
        self.show_dataset_title.setFont(font)
        self.show_dataset_title.setObjectName("show_dataset_title")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(60, 520, 61, 31))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(60, 570, 61, 31))
        font = QtGui.QFont()
        font.setFamily("Times New Roman")
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1115, 23))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # 选择图片
        self.load_categories()
        self.select_class.currentIndexChanged.connect(self.load_items)
        self.select_item.currentIndexChanged.connect(self.display_image)

        #加载图片
        self.load_Image.clicked.connect(self.load_image)

        #中值滤波
        self.median_filter.clicked.connect(self.apply_median_filter)

        #高斯滤波
        self.gaussian_filter.clicked.connect(self.apply_gaussian_filter)

        #LBP
        self.LBP.clicked.connect(self.apply_lbp)

        #HOG
        self.HOG.clicked.connect(self.apply_hog)

        #识别
        self.birds_classification.clicked.connect(self.birds_classification_clicked)

        self.show_eval.clicked.connect(self.show_eval_clicked)

    # 获取images目录下的子文件夹名字并添加到select_class
    def load_categories(self):
        image_dir = "D:\py_workspace\Bird Classification\CUB_200_2011\images"  # images目录路径，根据你的实际情况修改
        if os.path.isdir(image_dir):
            subfolders = [f for f in os.listdir(image_dir) if os.path.isdir(os.path.join(image_dir, f))]
            self.select_class.addItems(subfolders)


    #加载对应目录下的所有图片名字到item选项中
    def load_items(self):
        # 清除当前的select_item选项
        self.select_item.clear()

        # 获取当前选择的类别
        selected_class = self.select_class.currentText()

        # 获取所选类别文件夹中的jpg文件并添加到select_item
        image_dir = "D:\py_workspace\Bird Classification\CUB_200_2011\images"  # images目录路径，根据你的实际情况修改
        class_dir = os.path.join(image_dir, selected_class)

        if os.path.isdir(class_dir):
            image_files = [f for f in os.listdir(class_dir) if f.endswith(".jpg")]
            self.select_item.addItems(image_files)

    #根据目录选择图片并展示
    def display_image(self):
        # 获取当前选择的类别和项目
        selected_class = self.select_class.currentText()
        selected_item = self.select_item.currentText()

        # 构建图像文件路径
        image_path = os.path.join("D:\py_workspace\Bird Classification\CUB_200_2011\images", selected_class, selected_item)

        # 创建一个QPixmap并设置给showdataset中的QGraphicsView
        pixmap = QPixmap(image_path)

        scene = QGraphicsScene()
        view = QGraphicsView(self.showdataset)
        view.setScene(scene)
        view.setRenderHint(QPainter.Antialiasing)

        view.setSceneRect(0, 0, pixmap.width(), pixmap.height())
        view.fitInView(scene.sceneRect(), Qt.KeepAspectRatio)

        scene.addPixmap(pixmap)
        self.showdataset.setScene(scene)

    #显示load的图片
    def display_load_image(self, image_path):
        # 创建一个QPixmap
        pixmap = QPixmap(image_path)

        scene = QGraphicsScene()
        view = QGraphicsView(self.showdataset)
        view.setScene(scene)
        view.setRenderHint(QPainter.Antialiasing)

        view.setSceneRect(0, 0, pixmap.width(), pixmap.height())
        view.fitInView(scene.sceneRect(), Qt.KeepAspectRatio)

        scene.addPixmap(pixmap)

        # 在showresult中显示视图
        self.showresult.setScene(scene)

    #加载图片load image
    def load_image(self):
        options = QFileDialog.Options()
        options |= QFileDialog.ReadOnly
        file_dialog = QFileDialog()
        file_dialog.setNameFilter("Images (*.png *.xpm *.jpg *.bmp);;All Files (*)")
        file_path, _ = file_dialog.getOpenFileName(None, "Open Image File", "",
                                                   "Images (*.png *.xpm *.jpg *.bmp);;All Files (*)", options=options)
        if file_path:
            self.display_load_image(file_path)
            print(file_path)

    #中值滤波并在新窗口显示
    def apply_median_filter(self):
        # 获取当前显示的图像
        current_scene = self.showresult.scene()
        if current_scene:
            current_pixmap = current_scene.items()[0].pixmap()
            current_image = current_pixmap.toImage()

            # 将图像转换为OpenCV格式
            image_data = np.ndarray((current_image.height(), current_image.width(), 4), dtype=np.uint8)
            for y in range(current_image.height()):
                for x in range(current_image.width()):
                    pixel = current_image.pixel(x, y)
                    image_data[y, x] = [qRed(pixel), qGreen(pixel), qBlue(pixel), qAlpha(pixel)]

            # 进行中值滤波
            median_filtered_image = cv2.medianBlur(image_data, 5)  # 使用5x5的核进行中值滤波

            # 创建一个新的QImage来显示中值滤波后的图像
            median_filtered_qimage = QImage(median_filtered_image.data, current_image.width(), current_image.height(),
                                            current_image.bytesPerLine(), QImage.Format_RGBA8888)

            # 创建一个新的窗口来显示中值滤波后的图像
            filter_window = QDialog()
            filter_window.setWindowTitle("Median Filtered Image")
            filter_window.setGeometry(100, 100, current_image.width(), current_image.height())
            filter_scene = QGraphicsScene()
            filter_view = QGraphicsView(filter_scene)
            filter_view.setSceneRect(0, 0, current_image.width(), current_image.height())
            filter_scene.addPixmap(QPixmap.fromImage(median_filtered_qimage))
            filter_window.setLayout(QVBoxLayout())
            filter_window.layout().addWidget(filter_view)
            filter_window.exec_()

    #高斯滤波并在新窗口展示
    def apply_gaussian_filter(self):
        # 获取当前显示的图像
        current_scene = self.showresult.scene()
        if current_scene:
            current_pixmap = current_scene.items()[0].pixmap()
            current_image = current_pixmap.toImage()

            # 将图像转换为OpenCV格式
            image_data = np.ndarray((current_image.height(), current_image.width(), 4), dtype=np.uint8)
            for y in range(current_image.height()):
                for x in range(current_image.width()):
                    pixel = current_image.pixel(x, y)
                    image_data[y, x] = [qRed(pixel), qGreen(pixel), qBlue(pixel), qAlpha(pixel)]

            # 进行高斯滤波
            gaussian_filtered_image = cv2.GaussianBlur(image_data, (5, 5), 0)  # 使用5x5的核进行高斯滤波

            # 创建一个新的QImage来显示高斯滤波后的图像
            gaussian_filtered_qimage = QImage(gaussian_filtered_image.data, current_image.width(),
                                              current_image.height(), current_image.bytesPerLine(),
                                              QImage.Format_RGBA8888)

            # 创建一个新的窗口来显示高斯滤波后的图像
            filter_window = QDialog()
            filter_window.setWindowTitle("Gaussian Filtered Image")
            filter_window.setGeometry(100, 100, current_image.width(), current_image.height())
            filter_scene = QGraphicsScene()
            filter_view = QGraphicsView(filter_scene)
            filter_view.setSceneRect(0, 0, current_image.width(), current_image.height())
            filter_scene.addPixmap(QPixmap.fromImage(gaussian_filtered_qimage))
            filter_window.setLayout(QVBoxLayout())
            filter_window.layout().addWidget(filter_view)
            filter_window.exec_()

    #显示LBP图像
    def apply_lbp(self):
        # 获取当前显示的图像
        current_scene = self.showresult.scene()
        if current_scene:
            current_pixmap = current_scene.items()[0].pixmap()
            current_image = current_pixmap.toImage()

            # 将图像转换为OpenCV格式
            image_data = np.ndarray((current_image.height(), current_image.width(), 4), dtype=np.uint8)
            for y in range(current_image.height()):
                for x in range(current_image.width()):
                    pixel = current_image.pixel(x, y)
                    image_data[y, x] = [qRed(pixel), qGreen(pixel), qBlue(pixel), qAlpha(pixel)]

            # 转换图像为灰度图
            gray_image = cv2.cvtColor(image_data, cv2.COLOR_RGBA2GRAY)

            # 计算LBP特征图像
            lbp_radius = 1
            lbp_n_points = 8 * lbp_radius
            lbp_image = local_binary_pattern(gray_image, lbp_n_points, lbp_radius, method='uniform')

            # 将LBP图像的数据类型转换为np.uint8，并重新映射像素值到0到255范围内,很关键，没有的话LBP图像只有黑色和白点
            lbp_image = (lbp_image / np.max(lbp_image) * 255).astype(np.uint8)

            # 创建一个新窗口来显示LBP图像
            lbp_window = QDialog()
            lbp_window.setWindowTitle("LBP Features")
            lbp_window.setGeometry(100, 100, lbp_image.shape[1] * 2, lbp_image.shape[0] * 2)

            # 创建QGraphicsView来显示灰度图像
            gray_scene = QGraphicsScene()
            gray_view = QGraphicsView(gray_scene)
            gray_pixmap = QPixmap.fromImage(QImage(gray_image.data, gray_image.shape[1], gray_image.shape[0], gray_image.strides[0],QImage.Format_Grayscale8))
            gray_scene.addPixmap(gray_pixmap)

            # 创建QGraphicsView来显示LBP特征图像
            lbp_scene = QGraphicsScene()
            lbp_view = QGraphicsView(lbp_scene)
            lbp_pixmap = QPixmap.fromImage(QImage(lbp_image.data, lbp_image.shape[1], lbp_image.shape[0], lbp_image.strides[0], QImage.Format_Grayscale8))
            lbp_scene.addPixmap(lbp_pixmap)

            # 创建一个布局来组织这个视图
            layout = QVBoxLayout()
            layout.addWidget(gray_view)
            layout.addWidget(lbp_view)
            lbp_window.setLayout(layout)

            lbp_window.exec_()

    def apply_hog(self):
        # 获取当前显示的图像
        current_scene = self.showresult.scene()
        if current_scene:
            current_pixmap = current_scene.items()[0].pixmap()
            current_image = current_pixmap.toImage()

            # 将图像转换为OpenCV格式
            image_data = np.ndarray((current_image.height(), current_image.width(), 4), dtype=np.uint8)
            for y in range(current_image.height()):
                for x in range(current_image.width()):
                    pixel = current_image.pixel(x, y)
                    image_data[y, x] = [qRed(pixel), qGreen(pixel), qBlue(pixel), qAlpha(pixel)]

            # 转换图像为灰度图
            gray_image = cv2.cvtColor(image_data, cv2.COLOR_RGBA2GRAY)

            # 计算HOG特征图像
            _, hog_image = hog(gray_image, pixels_per_cell=(8, 8), cells_per_block=(2, 2), visualize=True, orientations=9)

            hog_image = (hog_image / np.max(hog_image) * 255).astype(np.uint8)

            # 创建一个新的窗口来显示图像和HOG特征图像
            hog_window = QDialog()
            hog_window.setWindowTitle("HOG Features")
            hog_window.setGeometry(100, 100, hog_image.shape[1] * 2, hog_image.shape[0] * 2)

            gray_scene = QGraphicsScene()
            gray_view = QGraphicsView(gray_scene)
            gray_pixmap = QPixmap.fromImage(QImage(gray_image.data, gray_image.shape[1], gray_image.shape[0], gray_image.strides[0],QImage.Format_Grayscale8))
            gray_scene.addPixmap(gray_pixmap)

            # 创建QGraphicsView来显示HOG特征图像
            hog_scene = QGraphicsScene()
            hog_view = QGraphicsView(hog_scene)
            hog_pixmap = QPixmap.fromImage(QImage(hog_image.data, hog_image.shape[1], hog_image.shape[0], hog_image.strides[0],QImage.Format_Grayscale8))
            hog_scene.addPixmap(hog_pixmap)

            # 创建一个布局来组织这个视图
            layout = QVBoxLayout()
            layout.addWidget(gray_view)
            layout.addWidget(hog_view)
            hog_window.setLayout(layout)

            hog_window.exec_()

    def get_classes(self, data_dir):
        all_data = datasets.ImageFolder(data_dir)
        return all_data.classes

    def apply_test_transforms(self, inp):
        out = transforms.functional.resize(inp, [224, 224])
        out = transforms.functional.to_tensor(out)
        out = transforms.functional.normalize(out, [0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        return out

    def predict(self, filepath):
        im = Image.open(filepath)
        loaded_model = torchvision.models.efficientnet_b0(pretrained=False)
        for param in loaded_model.parameters():
            param.requires_grad = False

        n_inputs = loaded_model.classifier[1].in_features

        dataset_path = "CUB_200_2011/images/"
        classes = self.get_classes(dataset_path)
        loaded_model.classifier = nn.Sequential(
            nn.Linear(n_inputs, 2048),
            nn.SiLU(),
            nn.Dropout(0.3),
            nn.Linear(2048, len(classes))
        )

        device = 'cuda' if torch.cuda.is_available() else 'cpu'
        loaded_model = loaded_model.to(device)
        # 加载保存的模型权重
        loaded_model.load_state_dict(torch.load('Best_model.pth'))

        # 将模型设置为评估模式（如果不打算继续训练）
        loaded_model.eval()


        im_as_tensor = self.apply_test_transforms(im)
        minibatch = torch.stack([im_as_tensor])
        if torch.cuda.is_available():
            minibatch = minibatch.cuda()
        pred = loaded_model(minibatch)
        _, classnum = torch.max(pred, 1)
        return classes[classnum]

    def birds_classification_clicked(self):
        # 获取当前显示的图像
        current_scene = self.showresult.scene()
        if current_scene:
            current_pixmap = current_scene.items()[0].pixmap()
            current_image = current_pixmap.toImage()

            # 将图像保存到临时文件
            temp_image_path = "temp_image.jpg"
            current_image.save(temp_image_path, "jpg")

            start_time = time.time()
            # 调用 predict 函数进行分类
            predicted_class = self.predict(temp_image_path)
            end_time = time.time()

            # 计算分类所需时间
            classification_time = end_time - start_time

            # 更新 classification_result 标签
            self.classification_result.setText(f"Classification result: {predicted_class}\nTime taken: {classification_time:.2f} seconds")

    def show_eval_clicked(self):
        # 打开 eval.txt 文件并显示其内容
        try:
            with open("eval.txt", "r") as file:
                eval_text = file.read()
                print(1)
                # 创建一个文本编辑框并显示 eval.txt 文件的内容
                self.textEdit = QTextEdit(self.centralwidget)
                self.textEdit.setGeometry(QtCore.QRect(60, 660, 1000, 60))
                self.textEdit.setPlainText(eval_text)
                self.textEdit.setReadOnly(True)  # 使文本编辑框只读
                self.textEdit.setObjectName("textEdit")
                self.textEdit.show()
        except FileNotFoundError:
            # 如果文件不存在，显示错误消息
            self.textEdit = QTextEdit(self.centralwidget)
            self.textEdit.setGeometry(QtCore.QRect(20, 670, 1000, 40))
            self.textEdit.setPlainText("eval.txt not found!")
            self.textEdit.setReadOnly(True)
            self.textEdit.setObjectName("textEdit")

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.load_Image.setText(_translate("MainWindow", "Load Image"))
        self.Title.setText(_translate("MainWindow", "Pytorch CUB-birds-200 Classification"))
        self.classification_result.setText(_translate("MainWindow", "Classification result:"))
        self.Author.setText(_translate("MainWindow", "by 19200120 Guodong Chen"))
        self.median_filter.setText(_translate("MainWindow", "Image Denoising median filter"))
        self.gaussian_filter.setText(_translate("MainWindow", "Image Denoising gaussian filter"))
        self.LBP.setText(_translate("MainWindow", "LBP"))
        self.HOG.setText(_translate("MainWindow", "HOG"))
        self.birds_classification.setText(_translate("MainWindow", "Birds Classification"))
        self.show_eval.setText(_translate("MainWindow", "Show model information"))
        self.show_dataset_title.setText(
            _translate("MainWindow", "Browse, Query, and Retrieve the Database by Category"))
        self.label.setText(_translate("MainWindow", "class:"))
        self.label_2.setText(_translate("MainWindow", "item:"))


if __name__ == '__main__':
    import sys
    from PyQt5.QtWidgets import QApplication, QMainWindow

    # import pics_ui_rc # 导入添加的资源（根据实际情况填写文件名）
    app = QApplication(sys.argv)
    MainWindow = QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
